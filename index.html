<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 style="color:#f2983f;font-size:40pt;">
〈Silk〉
</h1>
<p style="padding:10px;border-top:5px solid #f2983f;background-color:#eee;font-size:13pt;">
<a href="./index.html">Overview</a> <span style="padding-left:20px"></span> <a href="https://github.com/AjayMT/silk">Source Code</a> <span style="padding-left:20px"></span> <a href="https://github.com/AjayMT/silk/issues">Bug Tracker</a> <span style="padding-left:20px"></span> <a href="./langref.html">Language Reference</a>
</p>
<br />
<details>
<summary>
Table of Contents
</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#semantics-and-features">Semantics and features</a>
<ul>
<li><a href="#mutability">Mutability</a></li>
<li><a href="#aggregate-types">Aggregate types</a></li>
<li><a href="#user-defined-types-and-parametric-polymorphism">User-defined types and parametric polymorphism</a></li>
<li><a href="#other-miscellaneous-things">Other miscellaneous things</a></li>
</ul></li>
<li><a href="#build">Build</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#todos-roadmap">TODOs / Roadmap</a></li>
<li><a href="#license">License</a></li>
</ul>
</nav>
</details>
<p>Silk is a small system programming language that I wrote for fun and clout. It is designed to be as flexible and simple as C, but more pleasant to write. To that end, Silk provides</p>
<ul>
<li>nicer syntax</li>
<li>a sophisticated type system (including parametric types!)</li>
<li>a sense of pride and accomplishment</li>
</ul>
<p>Silk does not aim to be as safe or fast as C++, Rust, etc. The LLVM backend (you didn’t think I wrote an end-to-end compiler, did you?) does all of the optimization.</p>
<p>As is true of many of my projects, Silk is currently <strong>alpha</strong>-stage software.</p>
<h2 id="syntax">Syntax</h2>
<p>Silk is heavily inspired by <a href="https://golang.org/">Go</a> and other modern programming languages.</p>
<pre><code>// this is a comment

extern func printf(s *i8) void;

func main(argc i32, argv **i8) i32 {
  printf(&quot;hello, world\n&quot;);

  if argc &gt; 1 {
    val arg = @(argv + 1);
    printf(arg);
  }

  return 0;
}</code></pre>
<p>Notably,</p>
<ul>
<li>types come after names</li>
<li><code>@</code> is the pointer dereference operator</li>
<li><code>val</code> and <code>var</code> are used to declare values and variables (whose types are inferred unless specified explicitly)</li>
<li><code>func</code>, <code>return</code>, <code>if</code>, <code>for</code> and <code>while</code> are familiar keywords</li>
<li><code>extern</code> declares a symbol defined in a different object file.</li>
</ul>
<p>Silk also features parametric polymorphism:</p>
<pre><code>func add:[$t] (a $t, b $t) $t {
  return a + b;
}

func main() i32 {
  val a = add:[i32](1, 2);
  val b = add:[i8](&#39;a&#39;, &#39;b&#39;);
  return a + i32(b);
}</code></pre>
<h2 id="semantics-and-features">Semantics and features</h2>
<p>Silk is an <strong>imperative</strong> and <strong>statically typed</strong> language.</p>
<p>Though safety is not a primary design goal, Silk’s features make writing unsafe code more difficult than it would otherwise be.</p>
<h3 id="mutability">Mutability</h3>
<p>The <code>val</code> and <code>var</code> keywords declare immutable values and mutable variables respectively. The immutability of values also applies to aggregate types (i.e structures and arrays).</p>
<pre><code>type my_type = struct(a i32, b i32, c i32);

func main() void {
  val foo = my_type(1, 2, 3);
  foo.a = 0; // produces a compiler error

  // bar is a zero-initialized array of 16 my_types
  val bar = [my_type; 16];
  bar[1].c = 2; // this also produces a compiler error
}</code></pre>
<p>Silk has distinct mutable and immutable pointer types. Taking the address of a value produces an immutable pointer, whereas taking the address of a variable produces a mutable pointer.</p>
<pre><code>type my_type = struct(a i32, b i32, c i32);

func main() void {
  val foo = my_type(1, 2, 3);
  var foo_addr *my_type = &amp;foo;
  // foo_addr is an immutable pointer.
  // it is a var and can therefore be re-assigned
  // but cannot be write-dereferenced
  @foo_addr.a = 0; // produces a compiler error

  var bar = my_type(4, 5, 6);
  val bar_addr mut*my_type = &amp;bar;
  // bar_addr is a mutable pointer, which cannot be re-assigned
  // but can be write-dereferenced
  @bar_addr.b = 7;
}</code></pre>
<p>Mutable and immutable pointers can never be cast to/from each other. A mutable pointer can be <em>promoted</em> to an immutable pointer when passed as an argument to a function – the function cannot mutate the object unless it also has a mutable pointer or direct access to the object.</p>
<pre><code>// p is an immutable *i32
func f(p *i32) void {
  @p = 12; // this produces a compiler error
}

func main() void {
  var a = 12;
  val a_addr = &amp;a;
  // a_addr is a mut*i32 that is promoted to an immutable *i32
  f(a_addr);
  // but it is still a mutable pointer in this function
  @a_addr = 13;
}</code></pre>
<p>Additionally, only mutable pointers can be cast to/from integers. Silk’s mutability rules guarantee that:</p>
<ul>
<li>mutable pointers never point to immutable objects</li>
<li>immutable pointers can only point to mutable objects when the objects can be mutated in the same function
<ul>
<li>(or when the objects are mutated elsewhere concurrently, but that’s a big can of worms)</li>
</ul></li>
</ul>
<h3 id="aggregate-types">Aggregate types</h3>
<p>Silk’s aggregate types behave similarly to their C counterparts, with a few key differences.</p>
<p><strong>Arrays</strong> do not decay to pointers as in C. They generally behave as a single entity of data, much like structures.</p>
<pre><code>func g(arr *i32) void {}

func f(arr [3]i32) void {}

func main() void {
  val a = { 1, 2, 3 };
  g(a); // this produces a compiler error
  f(a); // this does not
  g(&amp;a[0]); // this does not

  val b = [i32; 3];
  // b is a zero-initialized array of 3 i32s
  f(b);
}</code></pre>
<p>Silk does not support variable-length arrays. The size of every array must be known at compile time and is part of its type.</p>
<p><strong>Structures</strong> are either <em>labeled</em> (every member has a name) or <em>unlabeled</em>. Unlabeled structures can be constructed with <em>struct literals</em>:</p>
<pre><code>func main() void {
  var a = (1, 2, 3);
  // (1, 2, 3) is a struct literal
  // a is of type struct(i32, i32, i32)

  var b = a.0; // its members are accessed by &#39;index&#39;
  var c = a.1;
  var d = a.2;
}</code></pre>
<p>Labeled structs can be defined as newtypes or constructed ad-hoc:</p>
<pre><code>type my_type = struct(num i32, chr i8, flag bool);

func main() void {
  var beans = my_type(1, &#39;B&#39;, true);
  var b = beans.num;
  // beans has members &#39;num&#39;, &#39;chr&#39; and &#39;flag&#39;

  var cake = struct(asdf i32, qwer u32)(12, 12u);
  var x = cake.qwer;
  // cake has members &#39;asdf&#39; and &#39;qwer&#39;
}</code></pre>
<p>Structures are aligned by default, but can be <em>packed</em>.</p>
<pre><code>type packed_type = packed(a i32, b i32, c i32);

func main() void {
  val a = (: 1, 2, 3 :);
  // a is a packed unlabeled struct

  val b = packed_type(4, 5, 6);
  // b is a packed labeled struct
}</code></pre>
<h3 id="user-defined-types-and-parametric-polymorphism">User-defined types and parametric polymorphism</h3>
<p>Types are defined with the <code>type</code> keyword:</p>
<pre><code>type int = i32;

func main() int {
  val a int = 12;
  val b i32 = a;
  return b;
}</code></pre>
<p>Notice that the <code>int</code> type defined in the previous example is not a newtype; it is an alias for <code>i32</code>.</p>
<p>Unlike other types, structs are unique. To define a newtype, simply use a one-member struct:</p>
<pre><code>type my_i32 = struct(i32);
type other_i32 = struct(i32);

func main() my_i32 {
  val a = 12;
  val b = my_i32(a);
  val c = other_i32(b.0);
  // a, b, c are of distinct types
}</code></pre>
<p>Forward declaring a type allows it to be defined recursively. A singly linked list type could be defined as follows:</p>
<pre><code>type list;
type list = struct(value i32, next mut*list);

func make_list_node(value i32) {
  return list(value, mut*list (0));
}

func main() i32 {
  var head = make_list_node(1);
  var tail = make_list_node(2);
  head.next = &amp;tail;

  return @(head.next).value;
}</code></pre>
<p>Silk’s types and functions can also accept type parameters:</p>
<pre><code>// binary tree with key and value
type bintree:[$key_type, $value_type];
type bintree:[$kt, $vt] = struct(
  key $kt, value $vt,
  left mut*bintree:[$kt, $vt],
  right mut*bintree:[$kt, $vt]
);

func make_bintree_node:[$kt, $vt](key $kt, value $vt) bintree:[$kt, $vt] {
  val null = mut*bintree:[$kt, $vt] (0);
  return bintree:[$kt, $vt](key, value, null, null);
}

func main() i32 {
  var root = make_bintree_node:[*i8, i32](&quot;hello&quot;, 1);
  var child = make_bintree_node:[*i8, i32](&quot;world&quot;, 2);
  root.right = &amp;child;
  return @(root.right).value;
}</code></pre>
<h3 id="other-miscellaneous-things">Other miscellaneous things</h3>
<p>Silk will never implicitly cast or coerce types. This is both a design choice and a product of my own laziness.</p>
<pre><code>func main() i32 {
  // a is of type u64 (&#39;u&#39;: unsigned, &#39;l&#39;: long i.e 64-bit)
  val a = 125ul;

  // this produces a compiler error since
  // 12 is an i32
  val b = a + 12;

  // these work as expected
  val c = a + 12ul;
  val d = a + u64(12);
}</code></pre>
<p>If every member in a struct literal is an lvalue, the struct literal can be an lvalue. This enables some cool ‘group’ assignment stuff.</p>
<pre><code>func main() i32 {
  var a = 1;
  var b = 2;
  var c = 3;
  val c_ptr = &amp;c;

  // all of the following statements assign
  // a, b, c to 4, 5, 6 respectively
  (a, b, c) = (4, 5, 6);
  (a, (b, c)) = (4, (5, 6));
  (a, b, @c_ptr) = (4, 5, 6);

  // this will swap a and b
  (a, b) = (b, a);

  return a;
}</code></pre>
<h2 id="build">Build</h2>
<p>In order to build Silk, you will need:</p>
<ul>
<li><a href="https://ocaml.org/">ocaml</a> toolchain</li>
<li><a href="https://dune.build/">dune</a> build tool</li>
<li><a href="http://gallium.inria.fr/~fpottier/menhir/">menhir</a> parser generator</li>
<li><a href="https://github.com/smolkaj/nice-parser">nice-parser</a> library</li>
</ul>
<p>Acquire the <a href="https://github.com/AjayMT/silk">source code</a> and execute:</p>
<pre><code>$ dune build --profile release @install
$ dune install</code></pre>
<p>This will place the <code>silk</code> executable in your opam <code>bin</code> directory.</p>
<p>Alternatively, simply run <code>build.sh</code> to place the <code>silk</code> executable in the source directory.</p>
<h2 id="usage">Usage</h2>
<p>In order to use Silk, you will need the <a href="http://llvm.org/">LLVM</a> toolchain.</p>
<p>Running <code>silk --help</code> will print a help message:</p>
<pre><code>The Silk compiler.

This program compiles one or more silk files (or input read
from stdin) and writes LLVM to stdout or the specified output
file.

Visit http://ajaymt.github.io/silk for documentation.

Usage: silk [options] [file...]

Options:
  -o &lt;file&gt;     Output file [default: stdout]
  -             Read input from stdin [default: false]
  --version     Print version number and exit
  --help        Print this help message and exit</code></pre>
<p><code>silk</code> reads the specified files (and/or stdin) and compiles them to LLVM. LLVM can be compiled to native object files with the <code>llc</code> tool.</p>
<p>For example:</p>
<pre><code>$ cat hello.silk
extern func printf(s *i8) void;

func main() i32 {
  printf(&quot;hello, world\n&quot;);
  return 0;
}
$ silk hello.silk -o hello.llvm
$ llc -filetype=obj hello.llvm -o hello.o
$ ld -o hello hello.o -lc
$ ./hello
hello, world</code></pre>
<p>The LLVM output can be compiled directly without writing it to a file:</p>
<pre><code>$ silk hello.silk | llc -filetype=obj -o hello.o -</code></pre>
<p>Silk does not include a preprocessor or package/module system of any kind. Your favorite C compiler can probably produce preprocessor output:</p>
<pre><code>$ cc -E -x c hello.silk &gt; hello.silk.out
$ # Compile hello.silk.out as described above</code></pre>
<h2 id="todos-roadmap">TODOs / Roadmap</h2>
<ul>
<li>Un-spaghetti the code and produce better error messages
<ul>
<li>Possibly by rewriting the whole thing</li>
</ul></li>
<li>Better type parameter syntax</li>
<li>Cool optimization stuff</li>
<li>More docs!</li>
</ul>
<h2 id="license">License</h2>
<p>Silk is distributed under the terms of the MIT License.</p>
<hr />
<p>Silk is one of my <a href="http://ajaymt.github.io/">many projects</a>. If you find this (or any of my work) interesting, please <a href="mailto:ajaymt2@illinois.edu">contact me</a>! I am <a href="https://www.linkedin.com/in/ajay-tatachar-980556193/">available for hire</a>.</p>
</body>
</html>
